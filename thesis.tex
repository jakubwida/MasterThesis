\documentclass[12pt, oneside]{report}

\usepackage[left=2.5cm, top=2.5cm, bottom=2.5cm, right=2.5cm]{geometry}

\usepackage[backend=bibtex,style=verbose-trad2]{biblatex}
\bibliography{bibliography}

\usepackage[utf8]{inputenc}
\usepackage[T1]{polski}
\usepackage[polish,english]{babel}
\selectlanguage{polish}
\usepackage{amsmath}
\usepackage{svg}
\usepackage{pdfpages}
\usepackage{float}
\usepackage{subcaption}

\begin{document}
\thispagestyle{empty}
\begin{titlepage}
    \begin{center}

           \Large
	\textbf{Uniwersytet Jagielloński w Krakowie}\vspace{0.2cm}\\ Wydział Fizyki, Astronomii i Informatyki Stosowanej
               \vspace*{1cm}

         \vspace{3cm}
         \Large
          \textbf{Jakub Wida}\\\vspace{0.5cm}
         \normalsize Nr albumu: 1113470\\
             \vspace{2cm}
        \Huge
        \textbf{Losowe upakowania układów złożonych z dysków z wykorzystaniem kart graficznych}

        \vspace{1.5cm}
        \normalsize
        Praca magisterska\\
        na kierunku Informatyka Stosowana\\ \vspace{0.15cm}

        \vfill
        \vspace{2cm}
       \begin{minipage}{1\textwidth}
\begin{flushright}
Praca wykonana pod kierunkiem\\
dr. hab. Michała Cieśli\\
z Zakładu Fizyki Statystycznej
\end{flushright}
\end{minipage}

        \vspace{2cm}
        \begin{center}
      Kraków 2019
        \end{center}
    \end{center}
\end{titlepage}

\newpage
 \thispagestyle{empty}
\vspace{2.5cm}
\begin{flushleft}
\large \textbf{Oświadczenie autora pracy}\vspace{0.6cm}\\
\end{flushleft}

\noindent Świadom odpowiedzialności prawnej oświadczam, że niniejsza praca dyplomowa została napisana przeze mnie samodzielnie i nie zawiera treści uzyskanych w sposób niezgodny z obowiązującymi przepisami.\\

\noindent Oświadczam również, że przedstawiona praca nie była wcześniej przedmiotem procedur związanych z uzyskaniem tytułu zawodowego w wyższej uczelni.
\vspace{2cm}
\begin{center}
\begin{tabular}{lr}
................................~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&
.......................................... \\
{~~~~Kraków, dnia} & {Podpis autora pracy~~~~}
\end{tabular}
\end{center}
\vspace{5cm}
\begin{flushleft}
\large \textbf{Oświadczenie kierującego pracą}
\end{flushleft}

\noindent Potwierdzam, że niniejsza praca została przygotowana pod moim kierunkiem i~kwalifikuje się do przedstawienia jej w postępowaniu o nadanie tytułu zawodowego.
\vspace{2cm}
\begin{center}
\begin{tabular}{lr}
................................~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&
............................................ \\
{~~~~Kraków, dnia} & {Podpis kierującego pracą~~}
\end{tabular}
\end{center}
\vfill


%INTRODUCTION ====================================================

\selectlanguage{english}

\chapter{Introduction}
{\bf TODO make this at the end, when all else is done}


%TABLE OF CONTENTS ====================================================

\tableofcontents
\newpage

%ACTUAL THESIS: INTRO ====================================================

%2-4 pages
\chapter{Problem Overwiev}
\section {Random Sequential Adsorbtion}

Random Sequential Adsorbtion is a stochastic process, that can be described as sequential insertion of given shapes onto an empty, limited euclidean space. The shapes are inserted with random position, and in such a way, that if the shape is colliding with an already inserted shape, it is then rejected in the process. The shapes and the space may be defined as having one or more dimensions, with any kind of inserted shape type. The shapes may be generated with random coordinates within given dimensions, as well as random rotation - although this may be optional.\autocite[1]{zhang}\autocite[1]{feder}

\subsection {Shape Types}

The inserted shape that were previously studied include rectangles, squares and other polygons, cubes and hypercubes. Also, the most basic shape usually investigated is a sphere - up to eight dimensions. Other studies involved spheroids, hyperdisks and, what is going to be further investigated in this thesis, disk polymers, or simply two dimensional groups of disks. In case of non spherical shapes, the shape angle can be randomly generated.\autocite[1]{zhang}

\subsection {Applications}

The Random Sequential Adsorbtion can be applied to multiple problems. The process as well as the generated shapes can be used to model a variety of phenomena. These include the ion implantation in semiconductors, structure of the cement paste, particles in cell membranes, protein adsorption and settlement of animal territories.\autocite[1]{zhang} In general, it can be used to model tightly - but still randomly - packed particles.
\newline

A significant example is the Poisson Disk Sampling, which is a process of selection of points in subdomain, in such a way that within a given distance from the selected point, no other are taken. This distribution is used in computer graphics for rendering, texture generation, and more. In ray tracing, it is used to create soft shadow, motion blur and the depth of field. In physics, it can be used for mesh generation, interpolation and process modeling. In some cases, the generated meshes have improved quality and are generated more robustly. \autocite[1]{ebeida}

\subsection {Challenges}

While the principle behind RSA algorithms is simple, the execution of it's naive implementations will commonly lead to problems. As the figures are randomly generated and inserted to the area, the probability of rejection of said shape will grow with the saturation of the system. In simpler words, the more figures are already inserted, the more likely it is that a new one will overlap a pre-existing one, which leads to long execution times and uncertain end conditions. The goal of many approaches is to propose an algorithm that will be able to quickly generate shapes within given space, and have clear end conditions signifying a fully saturated state.

\section {Thesis Goals}

This thesis focuses on one particular subset of RSA, namely, the generation of polydisks in two dimensional space. It's goal was to create an algorithm that would take advantage of great degree of parallelization available through using the GPU. A pre-existing algorithm developed by Michał Cieśla enables quick sequential or thread-level parallel generation of polydisks in a 2D area. Such algorithm can be used to simulate the packings of particles on a surface; Which itself is usefull in physics and material research.\autocite[1]{ciesla}

%ACTUAL THESIS: ALGORITHM OVERWIEV ====================================================

%5-15 pages
\chapter{Proposed Algorithm}

\section {Voxel-Based Algorithm}

The basic algorithm used in multiple RSA applications involves the use of voxels. The voxels are defined as subspaces of the saturated area, which cover it entirely. After one or more shapes are inserted, the voxels may be removed if within them no more figures can be inserted. Developing an algorithm for "voxel rejection" is the main concern of those undertakings. Only within the non-removed voxels the figures can be generated. After inserting more figures, if the voxels are not rejected or the figures are rejected too commonly - the voxels are split into smaller voxels to be able to further reject them. If all voxels are removed, the system is saturated. An example of such algorithm, using the two dimensional circles as shapes is demonstrated in the figures \ref{VoxelCircleRSApdff}, \ref{VoxelCircleRSApdfExamples}.

\begin{figure}

  \centering
	\includegraphics{Images/2dCircleRSA/VoxelCircleRSA.pdf}
  \caption{The flowchart of simple 2D RSA algorithm, using circles. \newline
		This algorithm can be expanded to remove voxels after every successful figure insertion, or to split voxels at a different condition.}

	\label{VoxelCircleRSApdff}
\end{figure}

\begin{figure}
  \centering

  \begin{subfigure}[b]{0.3\linewidth}
    \includegraphics[width=\linewidth]{Images/2dCircleRSA/fig1.pdf}
    \caption{}
  \end{subfigure}
  \begin{subfigure}[b]{0.3\linewidth}
    \includegraphics[width=\linewidth]{Images/2dCircleRSA/fig2.pdf}
    \caption{}
  \end{subfigure}
  \begin{subfigure}[b]{0.3\linewidth}
    \includegraphics[width=\linewidth]{Images/2dCircleRSA/fig3.pdf}
    \caption{}
  \end{subfigure}

  \begin{subfigure}[b]{0.3\linewidth}
    \includegraphics[width=\linewidth]{Images/2dCircleRSA/fig4.pdf}
    \caption{}
  \end{subfigure}
  \begin{subfigure}[b]{0.3\linewidth}
    \includegraphics[width=\linewidth]{Images/2dCircleRSA/fig5.pdf}
    \caption{}
  \end{subfigure}
  \begin{subfigure}[b]{0.3\linewidth}
    \includegraphics[width=\linewidth]{Images/2dCircleRSA/fig6.pdf}
    \caption{}
  \end{subfigure}

  \begin{subfigure}[b]{0.3\linewidth}
    \includegraphics[width=\linewidth]{Images/2dCircleRSA/fig7.pdf}
    \caption{}
  \end{subfigure}
  \begin{subfigure}[b]{0.3\linewidth}
    \includegraphics[width=\linewidth]{Images/2dCircleRSA/fig8.pdf}
    \caption{}
  \end{subfigure}
  \begin{subfigure}[b]{0.3\linewidth}
    \includegraphics[width=\linewidth]{Images/2dCircleRSA/fig9.pdf}
    \caption{}
  \end{subfigure}

  \caption{The figures illustrate a simple run of the described simple 2D RSA algorithm. \newline
		The world size is 10.0 by 10.0, the inserted circles have the radius of 2.0. The initial voxel side has length of 2.0. After 10 failed attempts at inserting the circle, the voxels are subdivied and rejected.\newline
		The figures \textit{a,b,c,d} show the insertion of the first four circles. The figure \textit{d} illustrates the effect of the voxel subdivision and rejection. Following figures illustrate next iterations of circle insertions, voxel subdivisions and removals, and finally, at figure \textit{i}, completely saturated system with no remaining voxels. \newline
		The voxels are rejected if they lie entirely within the double radius of any circle - in such case any circle generated within the voxel would collide with the evaluated circle. This is determined by examining if distance to all vertices of a voxel is less than the circle's doubled radius. This doubled radius is marked here as a solid red outline.}
  \label{VoxelCircleRSApdfExamples}
\end{figure}


\section {Sequential Algorithm}

The algorithm developed by dr. hab. Cieśla is an expansion on the previusly described basic model. However, some changes have been made to accomodate the algorithm to a different shape, more efficient execution and a modification in the behavior of space.

\subsection{Periodical Edge Conditions}

The algorithm was supposed to operate using a space that, unlike previously shown model, would \textit{loop} at the edges. This means, that if a shape is placed nearby the edge of given space, the shapes placed at the opposite edge of the space collide with it. They behave as if the opposite edge of the space would be a continuation of this edge. The periodical edge conditions serve to improve packing efficiency, and remove edge-related artifacts. In essence, the periodical edge conditions 'simulate' an infinite area, and thus may be helpful to model surfaces of far greater area than the provided space.\autocite[1]{ciesla_mziff}

\subsection{Adjacency Matrix}

During the execution of the algorithm, there are two places where a function must be performed at two objects, many different times. Firs, when the shape is inserted, it is determined if it collides with any other existing shape. The other time, it is when the voxel is rejected - it must be checked against all shapes, until one that would cause it's rejection is found. It is possible to limit the executions of these function to a far lesser number; By dividing the world into a number of cells, with sides as long as the radius of the shape's minimum binding circle, it is only nescessary to check the collisions of the shapes that belong to the same, or neighboring cells (similarly with voxels). This limits the number of collision checks that need to be performed to a theoretical maximum, based on how many shapes can fit into a three-by-three cell neighborhood. \newline
This solution can also be helpful with the periodical edge conditions problem. Having a quick access to the cell given it's coordinates enables the program to easily reference shapes from the opposite edge, by tapping into the target cell and translating the shapes stored by it.

\subsection{Polydisk Collision}

Since the algorithm uses a shape consisting of a list of disks with given radiuses and a relative position to an arbitrary center, it is relatively easy to check if two such shapes collide. It is enough to loop over both lists of shapes' circles absolute positions, checking if any two collide. \newline

\subsection{Voxel Rejection}

The much more complex problem is the voxel rejection. The first problem is that since the shapes can have a different angle, this needs to be implemented in the voxels structure - the solution was to add a third dimension, representing the available angles in which the shapes may appear. \newline

The algorithm proposed by Michał Cieśla covers the solution to this problem.\autocite[1]{ciesla} \newline
The voxel is rejected if no new figure can be inserted within it, at any position or angle, because there exists at least one shape near the voxel, that would overlap any new polydisk. It is enough that one circle of these pre existing polydisks would overlap any new circle from a virtually inserted shape.
The voxel is represented by coordinates:
\begin{equation*}
(x,y,\alpha)
\end{equation*}
Where $x,y$ are it's carthesian position, while $\alpha$ represents it's orientation. \newline
The voxel's spatial size is represented by $\Delta r$ and angular by $\Delta \alpha$ \newline
The position of the virtually inserted disk is represented by:
\begin{equation*}
(x+f_x*\Delta r, y + f_y \cdot \Delta r, \alpha + f_{\alpha} \cdot \Delta \alpha)
\end{equation*}
where $f_x,f_y_f_{\alpha}$ are any numbers in range $(0,1]$. \newline
A disk, belonging to a pre-existing particle has radius: $r$ and position: $(x_0,y_0)$. The distance between the disk and the virtual disk is described as: \newline
\begin{equation*}
d(f_x,f_{\alpha})=d_x(f_x,f_{\alpha})+d_y(f_y,f_{\alpha})
\end{equation*}
where: \newline
\begin{equation*}
d_x(f_x,f_{\alpha})=[x+f_x \cdot \Delta r + R_i * cos(\alpha_i+f_alpha \cdot \Delta \alpha)-x_0]^2
\end{equation*}
\begin{equation*}
d_y(f_y,f_{\alpha})=[x+f_y \cdot \Delta r + R_i * sin(\alpha_i+f_alpha \cdot \Delta \alpha)-y_0]^2
\end{equation*}
where $R_i, \aplha_i$ are the length and angle of the vector pointing to $i$'th circle in a virtual molecule. \newline
If the maximal value of $d(f_x,f_{\alpha})$ is smaller than $(R_i + r)^2$ the shapes will always collide. \newline
In order to find the maximum of $d_x(f_x,f_{\alpha})$ the range of the $x$ coordinate of the $i$'th' disk of the virtually inserted shape must be determined, with an analogous action performed for $d_y(f_y,f_{\alpha})$. The range for the $x$ coordinate is:
\begin{equation*}
[x + R_i \cdot \min_{f_{\alpha} \in [0,1)} cos(\alpha_i + f_{\alpha} \cdot \Delta \alpha), x + \Delta r + R_i \cdot \max_{f_{\alpha} \in [0,1)} cos(\alpha_i + f_{\alpha} \cdot \Delta \alpha)]
\end{equation*}
where the maximum of trigonometric function is: $max (cos(\alpha), cos(\alpha + \Delta_{\alpha})) $ or
$1$ if $ \alpha<0<\alpha + \Delta \alpha $ or $ \alpha< 2 \pi <\alpha + \Delta \alpha$.
The maximum distance is obtained by comparing $x_0$ with both ends of this interval. \newline
The only difference between the original implementation of this algorithm and the proposed one is it's execution in GPU.

\begin{figure}[H]
  \centering
	\label{CieslaAlgorithmDemo}
	\includegraphics[width=0.7\textwidth,keepaspectratio]{Images/CieslaAlgorithm/drawing.pdf}
	\caption{The green disk is a part of a polydisk already placed within the packing, while the blue disk represents one from a virtual, inserted shape. If at every position and angle within the voxel, the distance between the circle centers is less than the sum of their radiuses, the voxel will be rejected. In this example, the voxel is accepted.}
\end{figure}

\section {Parallel Application}

Having the available algorithm for sequential execution, the main challenge consisted of modifying it to enable a highly parallel execution using the GPU. The modified algorithm executes some parts of the problem sequentially, as it was not possible to parallelize it entirely.

\subsection{Block Diagram}

\begin{figure}[H]
  \centering
	\label{GPURSABlockDiagramPdf}
	\includegraphics[width=0.9\textwidth,height=0.9\textheight,keepaspectratio]{Images/GPURSA/GPUDiagram1.pdf}
	\caption{This flowchart represents the proposed parallel algorithm. \newline
		Blocks on the right, within the 'GPU' column are executed in parallel, while those on the left are executed sequentially}
\end{figure}

\section {Implementation}

The implementation of the algorithm involved several challenges. It necessitated the use of programming tools capable of utilising the GPU processing. Also, a number of smaller auxillary tasks needed to be implemented as well, such as visualisation, optimisation of the figures, etc.

\subsection{PyCuda}

The Python programming language was chosen to implement these tasks. The ease of writing code, as well as the vast choice of available libraries were deemed crucial in implementing the algorithm. While, as an interpreted language, Python may lack some execution speed, as compared to C or C++, it can partially bridge that gap using the dedicated mathematical libraries such as NumPy. Also, the main acceleration would come from using the parallel approach by utilising the GPU.\autocite[1]{numpy} \newline
However, the Python interpreter has no built-in implementation of GPU parallelism, and must rely on external libraries to perform these operations. The library chosen for this task was PyCuda. This library enables the use of Nvidia CUDA's capabilities, simultaneously wrapping parts of it's execution into Python functions. While, it only provides functionalities for initialising the CUDA execution and some basic array operations in Python, it still greately simplifies the code as compared to pure C/C++ implementation. Any more complex parallel code must be written in C. As such, the code for the algorithm was divided into two parts, where all parallel operations were written in C using CUDA library, while all sequential implementation used Python with PyCuda to initialise and communicate with the GPU-parallel part.\autocite[1]{pycuda}


\subsection{Step-by-step examination}

\subsubsection{Initialisation}

The starting parameters of the algorithm include:
\begin{itemize}
  \item \textbf{The shape configuration} (circle positions and radiuses relative to the shape origin).
  \item \textbf{Number of added shapes} per iteration.
  \item Adjacency matrix \textbf{cell size} (must be greater than the shape size).
  \item \textbf{World size} (in number of adjacency matrix cells).
	\item \textbf{Voxel split treshold} - the proportion of added shapes that were rejected that would trigger the voxel split.
\end{itemize}
As these parameters are set, a number of additional functions are executed. The shape area is being calculated, and the shape itself is being optimised. The latter involves re-calculating the origin of the shape, so that it's bounding circle is the smallest. These functions are auxillary to the main algorithm.
\newline
During the initialisation, there are created the data structures used throught the further execution. These involve:
\begin{itemize}
  \item \textbf{The shape array}: An array with shape: 3xN, where N is the number of shapes in the packing. Every row has the shape's coordinates (x,y) and it's angle.
  \item \textbf{The neighborhood matrix}: The 3D array with shape: CXxCYxSPN where CX and CY are the world dimensions in numbers of cells, while SPN is the theoretical maximum of figures per 3x3 cells (overestimated approximate). Such groupings of cells are here referred to as the "neighborhoods", and they contains the indexes of shapes that may collide with a shape in a given adjacency matrix cell. This whole data structure serves as the adjacency matrix.
  \item \textbf{The voxel array}: Similar to the shape array, it contains the spatial and angular positions of the existing voxels.
\end{itemize}
Additionally, there are set variables that are subject to change: the \textbf{current voxel spatial size} and the \textbf{current voxel angular size}.
Finally, the CUDA parallel execution is initialised, and it's pseudorandom generator is seeded with the current time.

\subsubsection{Part A: Shape generation}

\begin{figure}[H]
  \centering
	\label{GPURSA_Process_1}
	\includegraphics[width=0.9\textwidth,keepaspectratio]{Images/GPURSA/Figure_1.pdf}
	\caption{The packing after several iterations, before generating a new set of shapes.\newline
	The existing shapes are marked in red. The shapes appearing at the edges, as a part of periodical boundary conditons are green. The faint circles around the shapes are their bounding circles. The voxels are represented by gray squares, while the blue, empty squares are the adjacency matrix cells.}
\end{figure}

\begin{figure}[H]
  \centering
	\label{GPURSA_Process_1}
	\includegraphics[width=0.9\textwidth,keepaspectratio]{Images/GPURSA/Figure_2.pdf}
	\caption{The packing after shape generation. The new shapes (blue) were generated randomly at existing voxels.}
\end{figure}

This part is executed entirely in parallel. \newline
In this part, an additional array, \textbf{the added shape array} is created. It will be later merged with \textbf{the shape array}. \newline
A number of CUDA threads is created, equal to \textbf{the number of added shapes}. Every thread randomly picks a voxel from the \textbf{the voxel array}. A shape is generated with it's poisition and angle within the voxel. The resulting shapes are put into the \textbf{the added shape array}.

\subsubsection{Part B: Shape rejection against pre-existing shapes}

\begin{figure}[H]
  \centering
	\label{GPURSA_Process_2}
	\includegraphics[width=0.9\textwidth,keepaspectratio]{Images/GPURSA/Figure_3.pdf}
	\caption{Packing after rejection of shapes against the pre-existing ones. Only small groupings of new shapes remain.}
\end{figure}

This part is executed entirely in parallel. \newline
The same GPU threads are used as in the last part, each corresponding to a generated shape. The shapes' adjacency matrix cell positions are calculated. Basing on this, the collision is detected between the shape in the thread and all of the already existing shapes in it's potential neighborhood. If the shape collides with any of the pre-existing shapes, it is rejected, which is marked by setting it's coordinates in \textbf{the added shape array} to [-1.0,-1.0,-1.0]

\subsubsection{Part C: Shape rejection against other new shapes}

\begin{figure}[H]
  \centering
	\label{GPURSA_Process_4}
	\includegraphics[width=0.9\textwidth,keepaspectratio]{Images/GPURSA/Figure_4.pdf}
	\caption{Packing after rejecting the remaining new shapes against each other.}
\end{figure}

This part is executed sequentially. \newline
\textbf{The added shape array} is returned from the CUDA execution, and "squashed" to remove all rejected shapes. Since the shapes do not collide against any pre-existing ones, only the collisions within the list of new shapes need to be calculated. A temporary, empty neighborhood matrix is created. Shapes are added to this matrix sequentially, and rejected if they collide with one existing there. When all shapes are added, the shapes are merged into the actual \textbf{neighborhood matrix}, and \textbf{the added shape array} is concatentated to \textbf{the shape array}.

\subsubsection{Part D: Voxel splitting}

\begin{figure}[H]
  \centering
	\label{GPURSA_Process_5}
	\includegraphics[width=0.9\textwidth,keepaspectratio]{Images/GPURSA/Figure_5.pdf}
	\caption{Packing after voxel splitting. Every old voxel has been split into eight new ones.}
\end{figure}

This part is executed entirely in parallel. \newline
If the proportion of figures succesfully added to the packing in the previous part is lower than \textbf{the voxel split treshold}, this part is executed. \newline
The number of CUDA threads is created, for every currently existing voxel. A temporary new array, \textbf{the new voxel array} is created, with eight times as many elements as \textbf{the voxel array}. In every thread, the voxel is being split into 8 new ones, each with halved dimensions, and given new positions, so that they cover the entirety of their "predecessor". These voxels are placed in \textbf{the new voxel array} which afterwards replaces \textbf{the voxel array}.
The values of \textbf{the voxel spatial size} and \textbf{the voxel angular size} are halved.

\subsubsection{Part E: Voxel rejection}

\begin{figure}[H]
  \centering
	\label{GPURSA_Process_5}
	\includegraphics[width=0.9\textwidth,keepaspectratio]{Images/GPURSA/Figure_6.pdf}
	\caption{Packing after voxel rejection. Voxels in which no new figure could have been insterted, were removed.}
\end{figure}

This part is executed partially in parallel, and partially sequentially. \newline
The number of CUDA threads is created, for every voxel in \textbf{the voxel array}. For every voxel, the Cieśla's voxel rejection algorithm is executed against every figure in the voxel's neighborhood. If any figure causes the voxel to be rejected, it is marked as such on \textbf{the voxel array}. \newline
After the parallel part is executed, the voxel array is returned to the CPU memory. It is "squashed" to remove the rejected voxels, and if the number of remaining voxels is equal to 0 - the algorithm stops.

\subsection{Shape optimisation}

During the initialisation, the provided shape configuration is being optimised. This task is performed by a separate module. The shape optimisation entails translating the shape's circles' positions so that the origin lies in the center of the polydisk's minimal bounding circle. This can lead to smaller possible adjacency matrix cell sizes, smaller neighborhoods, and thus more efficient figure and voxel rejection. \newline
The implemented algorithm will perform ideal optimisation only for some cases, while for others, it will create an oversetimated approximation of the bounding circle. The algorithm creates a bounding circle for the set of two circles, containing points laying furthest from each other. If there exists a circle with a point outside the initial bounding circle, the latter is expanded to cover the outlying circle. The coordinates of the circles are then translated, so that the center of the bounding cirlce is the new origin point.

\begin{figure}
  \centering

  \begin{subfigure}[b]{0.4\linewidth}
    \includegraphics[width=\linewidth]{Images/Auxillaries/unoptimised_fig.pdf}
    \caption{unoptimised shape}
  \end{subfigure}
  \begin{subfigure}[b]{0.4\linewidth}
    \includegraphics[width=\linewidth]{Images/Auxillaries/optimised_fig.pdf}
    \caption{optimised shape}
  \end{subfigure}

\caption{Both shapes are technically identical. Using the center of the minimal bounding circle as the origin point enables more effective use of the algorithm. The figure collision is determined only when the bounding circles overlap, and the minimal adjacency matrix cell size depends on their size.}
\end{figure}

\subsection{Other}

The shape area is calculated using the Shapely python geometry library.\autocite[1]{shapely} \newline
The images depicting the RSA iterations were created using the Matplotlib python plotting library.\autocite[1]{matplotlib}

\subsection{Result management}

In order to perform analisys of statistical data, some data concerning the algorithm run, besides the output list of figure positions, can be saved. They are saved to the "results.json" file, and include:
\begin{itemize}
  \item Number of figures and voxels
 	\item Proportion of the world's area covered by the figures
	\item Time taken to perform each part (A-D) of the algorithm
\end{itemize}
These data are saved per every iteration, as well as a summary, with the total execution time.

\subsection{Summary}
	%stuff in general

\textbf{TODO unfinished, do in near future}

%ACTUAL THESIS: RESULTS INVESTIGATION ====================================================

%15-25 pages - due to multiple pictures
\chapter{Results Examination}
\section{Performance Evaluation}

As the overall goal of this thesis is to create an efficient implementation of the RSA algorithm, determining the optimal parameters for the shortest execution time is crucial.

\subsection{theoretical complexity}

The calculational complexity of the single iteration can be described as: \newline
\begin{equation*}
	O(\text{iteration}) = O(A)+O(B)+O(C)+O(D)+O(E)
\end{equation*}
where $O(A)$,$O(B)$,$O(C)$ represent the calculational complexities of the parts of the algorithm demonstrated at figure \ref{GPURSABlockDiagramPdf}. The complexity of the figure generation phase is:
\begin{equation*}
	O(A) = O(\text{added shape number}/ \text{number of CUDA threads})
\end{equation*}
Assuming the 'ideal' situation, in which the number of CUDA threads available is greater than the number of added shapes, the complexity is $O(1)$ \newline
The complexity of rejecting new shapes against old ones is: \newline
\begin{equation*}
	O(B) = O(\text{added shape number}/ \text{number of CUDA threads } \cdot \text{ maximum number of shapes in neighborhood})
\end{equation*}
In 'ideal' situation, this will be $O(\text{maximum number of shapes in neighborhood})$ \newline
The complexity of rejecting new shapes against old ones is: \newline
\begin{equation*}
	O(C) = O(\text{number of surviving shapes } \cdot \text{ maximum number of shapes in neighborhood} \cdot \text{number of circles in a figure}^2)
\end{equation*}
As this part is not executed in parallel, it's execution time is predicted to be the greatest. Every surviving new shape must be checked against those new other ones, that belong in the same neighborhood. \newline
Voxel splitting is described as: \newline
\begin{equation*}
	O(D) = O(\text{voxel number}/ \text{number of CUDA threads } \cdot 8)
\end{equation*}
Again, in 'ideal' conditions, this value will approach $O(8)$ \newline
Finally, the voxel rejection complexity can be represented as:
\begin{equation*}
	O(B) = O(\text{voxel number } \cdot \text{ maximum number of shapes in neighborhood } \cdot \text{ number of circles in a figure}^2)
\end{equation*}
While in perfect conditions, this will take only a few iterations, if the number of voxels rises above the capabilities of the GPU, this part may be severely slowing down the execution of the algorithm.

\subsection{Investigating performance}

Outside of theoretical inquiries, the actual perforance was investigated. All calculations were performed using the 8GB RAM / Intel® Core™ i5-8250U CPU @ 1.60GHz × 8 / GeForce MX150 Lenovo laptop. The figure chosen for the preliminary calculations was a dimer, a polydisk made of two intersecting circles of identical radiuses, where the center of one of them is located at a radius distance from another's center. Also, due to frequent crashes due to the overuse of GPU memory, a limit was imposed on the number of voxels. If the number of voxels reaches more than 1 million, they will not be split any further. While it theoretically warps the results, it is partially an equivalent to setting a high voxel split treshold, and it enables to perform otherwise impossible calculations.

\begin{figure}[H]
  \centering
	\label{summary_dimer}
	\includegraphics[width=0.3\textwidth,keepaspectratio]{Images/SummaryOptimisation/dimer.pdf}
	\caption{The dimer used in the calculations.}
\end{figure}
The RSA algorithm was performed using this shape, for a set of configurations. These included space sizes (25x25, 50x50, 75x75, 100x100 cells), different numbers of polydisks added (512, 512*2, 512*4, 512*8, 512*16) and different voxel split tresholds (0.1,0.3,0.5,0.7,0.9). The cell size is equal to the polydisk's minimal bounding circle radius.
If the proportions of shapes that werent succesfully inserted is above the voxel split treshold, then they are split.

\begin{figure}[H]
  \centering
	\label{summary_res25}
	\includegraphics[width=0.9\textwidth,keepaspectratio]{Images/SummaryOptimisation/results_25.pdf}
	\caption{Space size: 25x25 cells. Execution time (seconds) for different voxel split tresholds. Different plots represent different added shape numbers. The results are an average per 5 trials at each different configuration.}
\end{figure}

\begin{figure}[H]
  \centering
	\label{summary_res50}
	\includegraphics[width=0.9\textwidth,keepaspectratio]{Images/SummaryOptimisation/results_50.pdf}
	\caption{Space size: 50x50 cells.}
\end{figure}

\begin{figure}[H]
  \centering
	\label{summary_res75}
	\includegraphics[width=0.9\textwidth,keepaspectratio]{Images/SummaryOptimisation/results_75.pdf}
	\caption{Space size: 75x75 cells. }
\end{figure}

\begin{figure}[H]
  \centering
	\label{summary_res100}
	\includegraphics[width=0.9\textwidth,keepaspectratio]{Images/SummaryOptimisation/results_100.pdf}
	\caption{Space size: 100x100 cells.}
\end{figure}

The relationship that is relatively easy to discern, is that the optimal number of figures added is related to the space size. At 25x25 cells, the most optimal added cell number is 512, however for 100x100, it's 512*16. While these results are consistent for most voxel split tresholds, at around 0.9, most execution times are both the lowest, and fairly similar across different added shape numbers. In order to investigate how exactly do these results appear, a more detailed look was taken at the process:

\begin{figure}[H]
  \centering
	\label{summary_detail_75_512x8_09}
	\includegraphics[width=0.9\textwidth,keepaspectratio]{Images/SummaryOptimisation/iter_75_512x8_09.pdf}
	\caption{More detailed look into a single execution of the algorithm at space of 75x75 cells. Added shape number is 512*8, voxel removal treshold at 0.9. The bar chart represents the time spent by algorithm at a particular execution part, at iteration. The line chart represents the numbers of voxels and figures at given iterations.}
\end{figure}

At one of the optimal configurations for 75x75 cell sized space, the total execution time was 4.772 seconds. Of which, 2.509 was devoted to rejecting shapes against other new shapes, making it 52.6\% of the total time. As the number of voxels skyrocketed at around third and seventh iterations, the time devoted to rejecting voxels also went up.

\begin{figure}[H]
  \centering
	\label{summary_detail_75_512x8_03}
	\includegraphics[width=0.9\textwidth,keepaspectratio]{Images/SummaryOptimisation/iter_75_512x8_03.pdf}
	\caption{More detailed look into a single execution of the algorithm at space of 75x75 cells. Added shape number is 512*8, voxel removal treshold at 0.3.}
\end{figure}

At the less optimal configuration, where the voxel removal treshold was changed to 0.3, the total time required for rejection of shapes against new fell; It was 1.943 seconds, 29.9\% of the total of 6.548 seconds. However the total time grew, as the 4.553 seconds of voxel rejection slowed down the algorithm.

\begin{figure}[H]
  \centering
	\label{summary_detail_75_512x1_03}
	\includegraphics[width=0.9\textwidth,keepaspectratio]{Images/SummaryOptimisation/iter_75_512x1_03.pdf}
	\caption{More detailed look into a single execution of the algorithm at space of 75x75 cells. Added shape number is 512*1, voxel removal treshold at 0.3.}
\end{figure}

At the configuration involving only 512 added shapes and voxel split treshold at 0.3, the time spent at rejection of shapes against new ones fell again. It was at 1.551 seconds, while the voxel rejection time grew to 11.865 seconds, with total of 13.487. \newline

In summary, the execution time optimisation is a race between making the voxel removal quicker against the shape rejection against new shapes. The first one grows when the voxels are rejected early, as demonstrated on \ref{summary_detail_75_512x8_03}. If the number of added shapes is small, the number of iteration grows, as it takes more time to fill the packing and reject the voxels, by adding shpes in their place.\newline
In this implementation, the voxels are primarily a measure of wether any new figures can be added, rather than an acceleration tool for adding new ones.

\textbf{ TODO unfinished, do later}

%ACTUAL THESIS: BIBLIOGRAPHY ====================================================

\newpage
\printbibliography

\end{document}
